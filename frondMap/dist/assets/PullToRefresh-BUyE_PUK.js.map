{"version":3,"file":"PullToRefresh-BUyE_PUK.js","sources":["../../src/hooks/usePullToRefresh.ts","../../src/components/PullToRefresh.tsx"],"sourcesContent":["import { useState, useRef, useCallback, useEffect } from 'react';\r\n\r\ninterface UsePullToRefreshOptions {\r\n  onRefresh: () => Promise<void>;\r\n  threshold?: number;\r\n  maxPull?: number;\r\n}\r\n\r\nexport function usePullToRefresh({\r\n  onRefresh,\r\n  threshold = 80,\r\n  maxPull = 120\r\n}: UsePullToRefreshOptions) {\r\n  const [pullDistance, setPullDistance] = useState(0);\r\n  const [isRefreshing, setIsRefreshing] = useState(false);\r\n  \r\n  // Use refs for values that need to be accessed in event handlers\r\n  // This prevents stale closure issues and avoids frequent re-binding\r\n  // 使用 ref 存储需要在事件处理器中访问的值，避免闭包捕获旧值问题\r\n  const startY = useRef(0);\r\n  const pullDistanceRef = useRef(0);\r\n  const isPullingRef = useRef(false);\r\n  const isRefreshingRef = useRef(false);\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n  const onRefreshRef = useRef(onRefresh);\r\n  \r\n  // Keep onRefresh ref updated\r\n  useEffect(() => {\r\n    onRefreshRef.current = onRefresh;\r\n  }, [onRefresh]);\r\n\r\n  // Sync isRefreshing to ref\r\n  useEffect(() => {\r\n    isRefreshingRef.current = isRefreshing;\r\n  }, [isRefreshing]);\r\n\r\n  // Check if user is at the top of the page (WebView compatible)\r\n  // 检测用户是否在页面顶部（兼容 WebView 环境）\r\n  const isAtTop = useCallback(() => {\r\n    const container = containerRef.current;\r\n    \r\n    // Method 1: Check all scroll sources for WebView compatibility\r\n    const windowScroll = window.scrollY || window.pageYOffset || 0;\r\n    const documentScroll = document.documentElement.scrollTop || 0;\r\n    const bodyScroll = document.body.scrollTop || 0;\r\n    const containerScroll = container?.scrollTop || 0;\r\n    \r\n    const scrollTop = Math.max(windowScroll, documentScroll, bodyScroll, containerScroll);\r\n    \r\n    // Method 2: Fallback using getBoundingClientRect for WebView compatibility\r\n    if (container) {\r\n      const rect = container.getBoundingClientRect();\r\n      const navHeight = 56; // Navigation bar height\r\n      // If container top is at or below nav height, we're at top\r\n      if (rect.top >= navHeight - 5) {\r\n        return true;\r\n      }\r\n    }\r\n    \r\n    return scrollTop <= 5;\r\n  }, []);\r\n\r\n  const handleTouchStart = useCallback((e: TouchEvent) => {\r\n    if (isRefreshingRef.current) return;\r\n    if (!isAtTop()) return;\r\n    \r\n    startY.current = e.touches[0].clientY;\r\n    isPullingRef.current = true;\r\n  }, [isAtTop]);\r\n\r\n  const handleTouchMove = useCallback((e: TouchEvent) => {\r\n    if (!isPullingRef.current || isRefreshingRef.current) return;\r\n    \r\n    const currentY = e.touches[0].clientY;\r\n    const diff = currentY - startY.current;\r\n    \r\n    // Only pull down, not up\r\n    if (diff < 0) {\r\n      pullDistanceRef.current = 0;\r\n      setPullDistance(0);\r\n      return;\r\n    }\r\n\r\n    // Prevent native overscroll/pull-to-refresh in iOS WebViews\r\n    // 阻止 iOS WebView 的原生橡皮筋效果和下拉刷新\r\n    if (diff > 5) {\r\n      e.preventDefault();\r\n      e.stopPropagation();\r\n    }\r\n    \r\n    // Apply resistance for a more natural feel\r\n    const resistance = 0.6;\r\n    const distance = Math.min(diff * resistance, maxPull);\r\n    pullDistanceRef.current = distance;\r\n    setPullDistance(distance);\r\n  }, [maxPull]);\r\n\r\n  const handleTouchEnd = useCallback(async () => {\r\n    if (!isPullingRef.current) return;\r\n    \r\n    isPullingRef.current = false;\r\n    // Read from ref to get the latest value (avoids stale closure)\r\n    // 从 ref 读取最新值，避免闭包捕获旧状态\r\n    const currentPullDistance = pullDistanceRef.current;\r\n    \r\n    if (currentPullDistance >= threshold && !isRefreshingRef.current) {\r\n      setIsRefreshing(true);\r\n      isRefreshingRef.current = true;\r\n      setPullDistance(threshold); // Keep at threshold during refresh\r\n      \r\n      try {\r\n        await onRefreshRef.current();\r\n      } finally {\r\n        setIsRefreshing(false);\r\n        isRefreshingRef.current = false;\r\n        pullDistanceRef.current = 0;\r\n        setPullDistance(0);\r\n      }\r\n    } else {\r\n      pullDistanceRef.current = 0;\r\n      setPullDistance(0);\r\n    }\r\n  }, [threshold]);\r\n\r\n  const handleTouchCancel = useCallback(() => {\r\n    isPullingRef.current = false;\r\n    pullDistanceRef.current = 0;\r\n    setPullDistance(0);\r\n  }, []);\r\n\r\n  // Stable event binding - handlers have minimal dependencies now\r\n  // 稳定的事件绑定 - 处理函数的依赖已最小化，避免频繁重新绑定\r\n  useEffect(() => {\r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n\r\n    // Use passive: false to allow preventDefault for touch events\r\n    const options = { passive: false };\r\n    \r\n    container.addEventListener('touchstart', handleTouchStart, options);\r\n    container.addEventListener('touchmove', handleTouchMove, options);\r\n    container.addEventListener('touchend', handleTouchEnd, { passive: true });\r\n    container.addEventListener('touchcancel', handleTouchCancel, { passive: true });\r\n\r\n    return () => {\r\n      container.removeEventListener('touchstart', handleTouchStart);\r\n      container.removeEventListener('touchmove', handleTouchMove);\r\n      container.removeEventListener('touchend', handleTouchEnd);\r\n      container.removeEventListener('touchcancel', handleTouchCancel);\r\n    };\r\n  }, [handleTouchStart, handleTouchMove, handleTouchEnd, handleTouchCancel]);\r\n\r\n  const progress = Math.min(pullDistance / threshold, 1);\r\n\r\n  return {\r\n    containerRef,\r\n    isPulling: isPullingRef.current,\r\n    isRefreshing,\r\n    pullDistance,\r\n    progress\r\n  };\r\n}\r\n","import { ReactNode, CSSProperties } from 'react';\r\nimport { RefreshCw } from 'lucide-react';\r\nimport { usePullToRefresh } from '@/hooks/usePullToRefresh';\r\nimport { cn } from '@/lib/utils';\r\n\r\ninterface PullToRefreshProps {\r\n  children: ReactNode;\r\n  onRefresh: () => Promise<void>;\r\n  className?: string;\r\n}\r\n\r\nexport function PullToRefresh({ children, onRefresh, className }: PullToRefreshProps) {\r\n  const { containerRef, isRefreshing, pullDistance, progress } = usePullToRefresh({\r\n    onRefresh,\r\n    threshold: 80,\r\n    maxPull: 120\r\n  });\r\n\r\n  // Styles to prevent iOS overscroll conflicts\r\n  const containerStyle: CSSProperties = {\r\n    overscrollBehavior: 'none',\r\n    WebkitOverflowScrolling: 'touch',\r\n  };\r\n\r\n  return (\r\n    <div \r\n      ref={containerRef} \r\n      className={cn(\"relative\", className)}\r\n      style={containerStyle}\r\n    >\r\n      {/* Pull indicator */}\r\n      <div \r\n        className=\"absolute left-1/2 -translate-x-1/2 z-50 flex items-center justify-center transition-opacity duration-200 pointer-events-none\"\r\n        style={{ \r\n          top: Math.max(pullDistance - 50, 8),\r\n          opacity: pullDistance > 20 ? 1 : 0\r\n        }}\r\n      >\r\n        <div className={cn(\r\n          \"w-10 h-10 rounded-full bg-background/90 backdrop-blur-sm shadow-lg flex items-center justify-center border border-border/50\",\r\n          isRefreshing && \"animate-pulse\"\r\n        )}>\r\n          <RefreshCw \r\n            className={cn(\r\n              \"w-5 h-5 text-primary transition-transform duration-200\",\r\n              isRefreshing && \"animate-spin\"\r\n            )}\r\n            style={{ \r\n              transform: isRefreshing \r\n                ? undefined \r\n                : `rotate(${progress * 360}deg)` \r\n            }}\r\n          />\r\n        </div>\r\n      </div>\r\n      \r\n      {/* Content with pull transform */}\r\n      <div \r\n        style={{ \r\n          transform: pullDistance > 0 ? `translateY(${pullDistance}px)` : undefined,\r\n          transition: pullDistance === 0 ? 'transform 0.3s ease-out' : undefined\r\n        }}\r\n      >\r\n        {children}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n"],"names":["usePullToRefresh","onRefresh","threshold","maxPull","pullDistance","setPullDistance","useState","isRefreshing","setIsRefreshing","startY","useRef","pullDistanceRef","isPullingRef","isRefreshingRef","containerRef","onRefreshRef","useEffect","isAtTop","useCallback","container","windowScroll","documentScroll","bodyScroll","containerScroll","scrollTop","handleTouchStart","handleTouchMove","diff","distance","handleTouchEnd","handleTouchCancel","options","progress","PullToRefresh","children","className","containerStyle","jsxs","cn","jsx","RefreshCw"],"mappings":"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"}