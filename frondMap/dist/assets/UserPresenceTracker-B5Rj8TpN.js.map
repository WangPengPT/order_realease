{"version":3,"file":"UserPresenceTracker-B5Rj8TpN.js","sources":["../../src/hooks/useUserPresence.ts","../../src/components/UserPresenceTracker.tsx"],"sourcesContent":["import { useEffect, useRef } from 'react';\r\nimport { supabase } from '@/integrations/supabase/client';\r\nimport { useAuth } from '@/contexts/AuthContext';\r\nimport { isInWebView } from '@/lib/externalLinks';\r\n\r\nconst LOCATION_CACHE_KEY = \"location_cache\";\r\n\r\ninterface LocationData {\r\n  country: string | null;\r\n  city: string | null;\r\n  ip: string | null;\r\n}\r\n\r\n// Get cached location data from sessionStorage\r\nconst getCachedLocation = (): LocationData | null => {\r\n  try {\r\n    const cached = sessionStorage.getItem(LOCATION_CACHE_KEY);\r\n    if (cached) {\r\n      const data = JSON.parse(cached);\r\n      return {\r\n        country: data.country || null,\r\n        city: data.city || null,\r\n        ip: data.ip || null,\r\n      };\r\n    }\r\n  } catch {\r\n    // Ignore parse errors\r\n  }\r\n  return null;\r\n};\r\n\r\n// Cache location data to sessionStorage\r\nconst cacheLocation = (data: LocationData): void => {\r\n  try {\r\n    sessionStorage.setItem(LOCATION_CACHE_KEY, JSON.stringify(data));\r\n  } catch {\r\n    // Ignore storage errors\r\n  }\r\n};\r\n\r\n// Fetch location data via Edge Function (avoids CORS and rate limits)\r\nconst fetchLocationData = async (): Promise<LocationData> => {\r\n  // Check cache first\r\n  const cached = getCachedLocation();\r\n  if (cached) {\r\n    return cached;\r\n  }\r\n\r\n  try {\r\n    const { data, error } = await supabase.functions.invoke('get-location');\r\n    \r\n    if (error) {\r\n      console.error(\"Failed to fetch location:\", error);\r\n      return { country: null, city: null, ip: null };\r\n    }\r\n\r\n    const locationData: LocationData = {\r\n      country: data?.country || null,\r\n      city: data?.city || null,\r\n      ip: data?.ip || null,\r\n    };\r\n\r\n    // Cache successful result\r\n    if (locationData.country || locationData.city) {\r\n      cacheLocation(locationData);\r\n    }\r\n\r\n    return locationData;\r\n  } catch (error) {\r\n    console.error(\"Failed to fetch location data:\", error);\r\n    return { country: null, city: null, ip: null };\r\n  }\r\n};\r\n\r\nexport const useUserPresence = () => {\r\n  const { user } = useAuth();\r\n  const channelRef = useRef<ReturnType<typeof supabase.channel> | null>(null);\r\n  const locationDataRef = useRef<{ country: string | null; city: string | null; ip: string | null } | null>(null);\r\n  const initDelayRef = useRef<NodeJS.Timeout | null>(null);\r\n\r\n  useEffect(() => {\r\n    if (!user?.id) return;\r\n\r\n    \r\n\r\n    const updatePresenceInDB = async (isOnline: boolean, includeLocation: boolean = false) => {\r\n      try {\r\n        // Check if user has valid session before updating\r\n        const { data: { session } } = await supabase.auth.getSession();\r\n        if (!session) {\r\n          console.warn('No active session, skipping presence update');\r\n          return;\r\n        }\r\n\r\n        const updateData: {\r\n          user_id: string;\r\n          is_online: boolean;\r\n          last_seen: string;\r\n          updated_at: string;\r\n          ip_address?: string | null;\r\n          city?: string | null;\r\n          country?: string | null;\r\n        } = {\r\n          user_id: user.id,\r\n          is_online: isOnline,\r\n          last_seen: new Date().toISOString(),\r\n          updated_at: new Date().toISOString()\r\n        };\r\n\r\n        if (includeLocation && locationDataRef.current) {\r\n          updateData.ip_address = locationDataRef.current.ip;\r\n          updateData.city = locationDataRef.current.city;\r\n          updateData.country = locationDataRef.current.country;\r\n        }\r\n\r\n        const { error } = await supabase\r\n          .from('user_presence')\r\n          .upsert(updateData, {\r\n            onConflict: 'user_id'\r\n          });\r\n\r\n        if (error) {\r\n          console.error('Error updating presence in DB:', error);\r\n        }\r\n      } catch (err) {\r\n        console.error('Error in updatePresenceInDB:', err);\r\n      }\r\n    };\r\n\r\n    const initializePresence = async () => {\r\n      // Fetch location data once\r\n      const locationData = await fetchLocationData();\r\n      locationDataRef.current = locationData;\r\n      \r\n\r\n      // Create presence channel with user.id as the presence key\r\n      // This ensures each user is tracked under their own user_id\r\n      const channel = supabase.channel('online-users', {\r\n        config: {\r\n          presence: {\r\n            key: user.id, // Use user.id as the presence key\r\n          },\r\n        },\r\n      });\r\n\r\n      channel\r\n        .on('presence', { event: 'sync' }, () => {\r\n          const state = channel.presenceState();\r\n          \r\n        })\r\n        .subscribe(async (status) => {\r\n          \r\n          if (status === 'SUBSCRIBED') {\r\n            // Track user presence - data will be stored under the key (user.id)\r\n            const trackResult = await channel.track({\r\n              user_id: user.id,\r\n              online_at: new Date().toISOString(),\r\n            });\r\n            \r\n            \r\n            // Also update database record with location info\r\n            await updatePresenceInDB(true, true);\r\n          }\r\n        });\r\n\r\n      channelRef.current = channel;\r\n    };\r\n\r\n    // Always delay presence initialization to prioritize page rendering\r\n    // Use consistent 2 second delay for stable behavior across all environments\r\n    const initDelay = 2000;\r\n    \r\n    if (initDelay > 0) {\r\n      \r\n      initDelayRef.current = setTimeout(initializePresence, initDelay);\r\n    } else {\r\n      initializePresence();\r\n    }\r\n\r\n    // Heartbeat to update last_seen - use consistent 60 second interval\r\n    const heartbeatInterval = 60000;\r\n    const heartbeat = setInterval(() => {\r\n      updatePresenceInDB(true, false);\r\n      // Re-track presence to keep WebSocket alive\r\n      if (channelRef.current) {\r\n        channelRef.current.track({\r\n          user_id: user.id,\r\n          online_at: new Date().toISOString(),\r\n        });\r\n      }\r\n    }, heartbeatInterval);\r\n\r\n    // Handle visibility change\r\n    const handleVisibilityChange = () => {\r\n      if (document.visibilityState === 'visible') {\r\n        // Re-track presence when tab becomes visible\r\n        if (channelRef.current) {\r\n          channelRef.current.track({\r\n            user_id: user.id,\r\n            online_at: new Date().toISOString(),\r\n          });\r\n        }\r\n        updatePresenceInDB(true, false);\r\n      }\r\n    };\r\n\r\n    // Handle beforeunload - set offline in DB\r\n    const handleBeforeUnload = () => {\r\n      updatePresenceInDB(false, false);\r\n    };\r\n\r\n    document.addEventListener('visibilitychange', handleVisibilityChange);\r\n    window.addEventListener('beforeunload', handleBeforeUnload);\r\n\r\n    return () => {\r\n      \r\n      \r\n      // Clear init delay if still pending\r\n      if (initDelayRef.current) {\r\n        clearTimeout(initDelayRef.current);\r\n      }\r\n      \r\n      clearInterval(heartbeat);\r\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\r\n      window.removeEventListener('beforeunload', handleBeforeUnload);\r\n      \r\n      // Untrack and cleanup\r\n      if (channelRef.current) {\r\n        channelRef.current.untrack();\r\n        supabase.removeChannel(channelRef.current);\r\n      }\r\n      \r\n      updatePresenceInDB(false, false);\r\n    };\r\n  }, [user?.id]);\r\n};\r\n","import { useUserPresence } from '@/hooks/useUserPresence';\r\n\r\nexport const UserPresenceTracker = () => {\r\n  useUserPresence();\r\n  return null;\r\n};\r\n\r\nexport default UserPresenceTracker;\r\n"],"names":["LOCATION_CACHE_KEY","getCachedLocation","cached","data","cacheLocation","fetchLocationData","error","supabase","locationData","useUserPresence","user","useAuth","channelRef","useRef","locationDataRef","initDelayRef","useEffect","updatePresenceInDB","isOnline","includeLocation","session","updateData","err","initializePresence","channel","status","initDelay","heartbeat","handleVisibilityChange","handleBeforeUnload","UserPresenceTracker"],"mappings":"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"}